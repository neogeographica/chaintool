#!/usr/bin/env bash

if compopt 2> /dev/null
then
  true
else
  echo "Note: old bash shell version in use. Tab completion of directories for"
  echo "mbuild export/import arguments will have an annoying space at the end."
  if [[ $(uname -s) == "Darwin" ]]
  then
    echo "cf. https://itnext.io/upgrading-bash-on-macos-7138bd1066ba"
  fi
fi

_set_file_completions()
{
  CUR="$1"
  if compopt -o filenames 2> /dev/null
  then
    COMPREPLY=( $(compgen -f -- "$CUR") )
  else
    COMPREPLY=()
    local TEMP_COMPREPLY=$(compgen -f -- "$CUR")
    if [[ -n "$TEMP_COMPREPLY" ]]
    then
      while IFS= read -r COMP
      do
        if [[ -d "$COMP" ]]
        then
          COMPREPLY+=("$COMP/")
        else
          COMPREPLY+=("$COMP")
        fi
      done <<< "$TEMP_COMPREPLY"
    fi
  fi
}

_mbuild()
{
  # Memo-ize the word we're trying to complete.
  local CUR="${COMP_WORDS[$COMP_CWORD]}"

  # If it starts with a dash, for now we'll assume it's an option.
  local IS_FLAG=0
  if [[ "$CUR" == -* ]]
  then
    IS_FLAG=1
  fi

  # If this is the first word (after the program name itself), the only thing
  # it can be is the help option or a commandgroup.
  if [[ $COMP_CWORD == 1 ]]
  then
    if [[ $IS_FLAG == 1 ]]
    then
      COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
    else
      COMPREPLY=( $(compgen -S ' ' -W "cmd seq vals export import" -- "$CUR") )
    fi
    return 0
  fi

  # If this after the first word, bail out now if the first word was not a valid
  # commandgroup.
  local CMD_GROUP="${COMP_WORDS[1]}"
  echo "cmd seq vals export import" | grep -qw "$CMD_GROUP"
  if [[ $? -ne 0 ]]
  then
    return 0
  fi

  # OK! Things are still pretty simple for the second word. There is a small
  # number of valid options, or if the commandgroup was cmd/seq then this can
  # be an operation. For export/import we can do file completion.
  if [[ $COMP_CWORD == 2 ]]
  then
    if [[ $IS_FLAG == 1 ]]
    then
      if [[ "$CMD_GROUP" == "import" ]]
      then
        COMPREPLY=( $(compgen -W "--help --overwrite" -- "$CUR") )
      else
        COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
      fi
    else
      if [[ "$CMD_GROUP" == "cmd" || "$CMD_GROUP" == "seq" ]]
      then
        COMPREPLY=( $(compgen -W "list set edit info del run vals" -- "$CUR") )
      elif [[ "$CMD_GROUP" == "import" || "$CMD_GROUP" == "export" ]]
      then
        _set_file_completions "$CUR"
      fi
    fi
    return 0
  fi

  # XXX Need to handle export possibly having a filename after option(s) here.

  # After the second word we will only do completions for cmd/seq commandgroups.
  if [[ "$CMD_GROUP" != "cmd" && "$CMD_GROUP" != "seq" ]]
  then
    return 0
  fi

  # At this point we know we're in the cmd/seq commandgroups. Bail out now if
  # the second word was not a valid operation.
  local OPERATION="${COMP_WORDS[2]}"
  echo "list set edit info del run vals" | grep -qw "$OPERATION"
  if [[ $? -ne 0 ]]
  then
    return 0
  fi

  # We have a valid operation. Onward!

  # We can complete an option if the commandline doesn't have a prior "--",
  # and we can also complete on a command or sequence name depending on the
  # position of the argument. So we need to look through the arguments now.

  local NO_FLAGS=0
  local FOUND_FIRST_NAME=0
  local CUR_IS_NAME=0
  local CUR_IS_ALTNAME=0
  local CHECK_NAME_DEL=0
  local CHECK_ALTNAME_SET=0
  local CHECK_ALTNAME_RUN=0

  if [[ "$OPERATION" == "del" ]]
  then
    CHECK_NAME_DEL=1
  elif [[ "$CMD_GROUP" == "seq" && "$OPERATION" == "set" ]]
  then
    CHECK_ALTNAME_SET=1
  elif [[ "$CMD_GROUP" == "seq" && "$OPERATION" == "run" ]]
  then
    CHECK_ALTNAME_RUN=1
  fi

  # Scanning from word 3 up to our current position...
  for INDEX in $(seq 3 $COMP_CWORD)
  do
    local THIS_WORD="${COMP_WORDS[$INDEX]}"
    # Let's first handle looking for whether "--" appears before our word.
    if [[ "$THIS_WORD" == "--" && $INDEX != $COMP_CWORD ]]
    then
      NO_FLAGS=1
      if [[ $IS_FLAG == 1 ]]
      then
        # If our word starts with a hyphen, it's not actually an option since it
        # is after "--". But nothing we're currently able to match can start
        # with a hyphen, so bail out.
        # XXX This might change if we introduce filename matching for import/export?
        return 0
      fi
    # OK, is this a command name after a "-s" option for "seq run"?
    elif [[ $CHECK_ALTNAME_RUN == 1 && $INDEX == $COMP_CWORD && $NO_FLAGS == 0 ]]
    then
      local PREV_WORD="${COMP_WORDS[$INDEX-1]}"
      if [[ "$PREV_WORD"=="-s" || "$PREV_WORD"=="--skip" ]]
      then
        CUR_IS_ALTNAME=1
        break
      fi
    fi
    # If this word starts with a hyphen, nothing else to check about it.
    if [[ "$THIS_WORD" == -* ]]
    then
      continue
    fi
    # If we already found a positional-arg name in the command line, generally
    # we won't look for another one, except for "cmd/seq del" and "seq set".
    if [[ $FOUND_FIRST_NAME == 1 && $CHECK_NAME_DEL == 0 && $CHECK_ALTNAME_SET == 0 ]]
    then
      continue
    fi
    if [[ $INDEX == $COMP_CWORD ]]
    then
      if [[ $FOUND_FIRST_NAME == 1 && $CHECK_ALTNAME_SET == 1 ]]
      then
        # This is a command name (not the primary sequence name) for "seq set".
        CUR_IS_ALTNAME=1
        break
      fi
      # Either FOUND_FIRST_NAME is false, in which case this is the primary
      # command/sequence name, or we're doing "cmd/seq del" which allows
      # multiple names of the same type.
      CUR_IS_NAME=1
      break
    fi
    FOUND_FIRST_NAME=1
  done

  # Got all the info we need... time to get down to the completions.

  # If word is not a name or option then bail out.
  if [[ $IS_FLAG == 0 && $CUR_IS_NAME == 0 && $CUR_IS_ALTNAME == 0 ]]
  then
    return 0
  fi

  # "cmd/seq list" is simple; can only have a help option.
  if [[ "$OPERATION" == "list" ]]
  then
    if [[ $IS_FLAG == 1 ]]
    then
      COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
    fi
    return 0
  fi

  # For anything else we might have a name to complete.
  if [[ $CUR_IS_NAME == 1 ]]
  then
    if [[ "$CMD_GROUP" == "cmd" ]]
    then
      local CMDLIST=$("${COMP_WORDS[0]}" cmd list)
      COMPREPLY=( $(compgen -W "$CMDLIST" -- "$CUR") )
    else
      local SEQLIST=$("${COMP_WORDS[0]}" seq list)
      COMPREPLY=( $(compgen -W "$SEQLIST" -- "$CUR") )
    fi
    return 0
  elif [[ $CUR_IS_ALTNAME == 1 ]]
  then
    local CMDLIST=$("${COMP_WORDS[0]}" cmd list)
    COMPREPLY=( $(compgen -W "$CMDLIST" -- "$CUR") )
    return 0
  fi

  # If not, then we're just completing options.
  if [[ "$CMD_GROUP" == "cmd" ]]
  then
    if [[ "$OPERATION" == "set" || "$OPERATION" == "edit" || "$OPERATION" == "vals" ]]
    then
      COMPREPLY=( $(compgen -W "--help --quiet" -- "$CUR") )
    elif [[ "$OPERATION" == "info" || "$OPERATION" == "run" ]]
    then
      COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
    elif [[ "$OPERATION" == "del" ]]
    then
      COMPREPLY=( $(compgen -W "--help --force" -- "$CUR") )
    fi
  else
    if [[ "$OPERATION" == "set" || "$OPERATION" == "edit" ]]
    then
      COMPREPLY=( $(compgen -W "--help --force --quiet" -- "$CUR") )
    elif [[ "$OPERATION" == "info" || "$OPERATION" == "del" ]]
    then
      COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
    elif [[ "$OPERATION" == "run" ]]
    then
      COMPREPLY=( $(compgen -W "--help --ignore-errors --skip" -- "$CUR") )
    elif [[ "$OPERATION" == "vals" ]]
    then
      COMPREPLY=( $(compgen -W "--help --quiet" -- "$CUR") )
    fi
  fi
}
complete -F _mbuild mbuild

