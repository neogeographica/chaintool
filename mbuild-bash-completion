#!/usr/bin/env bash

# Bash completion implementation for the mbuild tool. Either paste all the
# code below into a file that will be sourced such as ~/.bash_completion
# or explicitly source this file from some other such file.


# Subroutine to populate COMPREPLY with file/directory completions.
_mbuild_file_completions()
{
  local CUR="${COMP_WORDS[$COMP_CWORD]}"
  if compopt -o filenames 2> /dev/null
  then
    # If compopt worked, we can just get filename completions and they will
    # automagically get trailing slashes (and no extra trailing space) if they
    # are directories.
    COMPREPLY=( $(compgen -f -- "$CUR") )
  else
    # If compopt failed, this is probably an old bash version. Likely to
    # happen on macOS, cf. https://itnext.io/upgrading-bash-on-macos-7138bd1066ba
    # We will try an alternate approach here; works pretty well but any
    # directory-name completions for import/export will have an annoying
    # space after the slash.
    COMPREPLY=()
    local TEMP_COMPREPLY=$(compgen -f -- "$CUR")
    if [[ -n "$TEMP_COMPREPLY" ]]
    then
      while IFS= read -r COMP
      do
        if [[ -d "$COMP" ]]
        then
          COMPREPLY+=("$COMP/")
        else
          COMPREPLY+=("$COMP")
        fi
      done <<< "$TEMP_COMPREPLY"
    fi
  fi
}

# Subroutine to populate COMPREPLY for operations in the "cmd" commandgroup.
_mbuild_cmd_completions()
{
  OPERATION="$1"
  NO_FLAGS="$2"
  HAS_PREV_POSITIONAL="$3"
  local CUR="${COMP_WORDS[$COMP_CWORD]}"
  local OPTLIST=""
  local POSLIST=""
  local MIGHT_MATCH_NAME=1
  if [[ "$CUR" == -* ]]
  then
    MIGHT_MATCH_NAME=0
  fi
  case "$OPERATION" in
    list)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help"
      fi
      ;;
    set)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --quiet"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 && $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" cmd list)
      fi
      ;;
    edit)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --quiet"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 && $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" cmd list)
      fi
      ;;
    info)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 && $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" cmd list)
      fi
      ;;
    del)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --force"
      fi
      if [[ $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" cmd list)
      fi
      ;;
    run)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 ]]
      then
        if [[ $MIGHT_MATCH_NAME == 1 ]]
        then
          POSLIST=$("${COMP_WORDS[0]}" cmd list)
        fi
      else
        # XXX Would do run placeholders here. Only bother to query if CUR is
        # empty or starts with a letter or + sign.
        true
      fi
      ;;
    vals)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --quiet"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 ]]
      then
        if [[ $MIGHT_MATCH_NAME == 1 ]]
        then
          POSLIST=$("${COMP_WORDS[0]}" cmd list)
        fi
      else
        # XXX Would do vals placeholders here. Only bother to query if CUR is
        # empty or starts with a letter or + sign.
        true
      fi
      ;;
  esac
  COMPREPLY=( $(compgen -W "$POSLIST $OPTLIST" -- "$CUR") )
}

# Subroutine to populate COMPREPLY for operations in the "seq" commandgroup.
_mbuild_seq_completions()
{
  OPERATION="$1"
  NO_FLAGS="$2"
  HAS_PREV_POSITIONAL="$3"
  local CUR="${COMP_WORDS[$COMP_CWORD]}"
  local BEFORE_CUR="${COMP_WORDS[$COMP_CWORD-1]}"
  local OPTLIST=""
  local POSLIST=""
  local MIGHT_MATCH_NAME=1
  if [[ "$CUR" == -* ]]
  then
    MIGHT_MATCH_NAME=0
  fi
  case "$OPERATION" in
    list)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help"
      fi
      ;;
    set)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --force --quiet"
      fi
      if [[ $MIGHT_MATCH_NAME == 1 ]]
      then
        if [[ $HAS_PREV_POSITIONAL == 0 ]]
        then
          POSLIST=$("${COMP_WORDS[0]}" seq list)
        else
          POSLIST=$("${COMP_WORDS[0]}" cmd list)
        fi
      fi
      ;;
    edit)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --force --quiet"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 && $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" seq list)
      fi
      ;;
    info)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 && $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" seq list)
      fi
      ;;
    del)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help"
      fi
      if [[ $MIGHT_MATCH_NAME == 1 ]]
      then
        POSLIST=$("${COMP_WORDS[0]}" seq list)
      fi
      ;;
    run)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --ignore-errors --skip"
      fi
      if [[ $MIGHT_MATCH_NAME == 1 ]]
      then
        if [[ $NO_FLAGS == 0 && ( "$BEFORE_CUR" == "-s" || "$BEFORE_CUR" == "--skip" ) ]]
        then
          POSLIST=$("${COMP_WORDS[0]}" cmd list)
        else
          if [[ $HAS_PREV_POSITIONAL == 0 ]]
          then
            POSLIST=$("${COMP_WORDS[0]}" seq list)
          else
            # XXX Would do run placeholders here. Only bother to query if CUR is
            # empty or starts with a letter or + sign.
            true
          fi
        fi
      fi
      ;;
    vals)
      if [[ $NO_FLAGS == 0 ]]
      then
        OPTLIST="--help --quiet"
      fi
      if [[ $HAS_PREV_POSITIONAL == 0 ]]
      then
        if [[ $MIGHT_MATCH_NAME == 1 ]]
        then
          POSLIST=$("${COMP_WORDS[0]}" seq list)
        fi
      else
        # XXX Would do vals placeholders here. Only bother to query if CUR is
        # empty or starts with a letter or + sign.
        true
      fi
      ;;
  esac
  COMPREPLY=( $(compgen -W "$POSLIST $OPTLIST" -- "$CUR") )
}

# Subroutine to populate COMPREPLY for operations in the "import" and
# "export" commandgroups.
_mbuild_import_export_completions()
{
  OPERATION="$1"
  NO_FLAGS="$2"
  HAS_PREV_POSITIONAL="$3"
  local CUR="${COMP_WORDS[$COMP_CWORD]}"
  local OPTLIST
  if [[ "$OPERATION" == "import" ]]
  then
    OPTLIST="--help --overwrite"
  else
    OPTLIST="--help"
  fi
  # If we've already got the filename, the only remaining valid things are
  # options.
  if [[ $HAS_PREV_POSITIONAL == 1 ]]
  then
    if [[ $NO_FLAGS == 0 ]]
    then
      COMPREPLY=( $(compgen -W "$OPTLIST" -- "$CUR") )
    fi
    return
  fi
  # We haven't got the filename yet.
  # If "--" has been provided, we know we are not interested in matching
  # against options, so provide file matches.
  if [[ $NO_FLAGS == 1 ]]
  then
    _mbuild_file_completions
    return
  fi
  if [[ "$CUR" == "" ]]
  then
    # TAB was pressed with nothing typed yet. We're in a position that could
    # accept an option or a filename -- instead of mixing the options with all
    # filename completions, just show a "<file>" placeholder.
    COMPREPLY=( $(compgen -W "$OPTLIST <file>" -- "$CUR") )
  elif [[ "$CUR" == -* ]]
  then
    # The first char is a hyphen. Since we are not preceded by a "--" then
    # this must be an option... don't bother to find filename completions.
    COMPREPLY=( $(compgen -W "$OPTLIST" -- "$CUR") )
  else
    # The first char is not a hyphen. Do the filename completions.
    _mbuild_file_completions
  fi
}

# Subroutine to populate COMPREPLY for operations in the "vals" commandgroup.
_mbuild_vals_completions()
{
  NO_FLAGS="$1"
  local CUR="${COMP_WORDS[$COMP_CWORD]}"
  local OPTLIST=""
  if [[ $NO_FLAGS == 0 ]]
  then
    OPTLIST="--help"
  fi
  # XXX Would do vals placeholders here. Only bother to query if CUR is
  # empty or starts with a letter or + sign.
  local POSLIST=""
  COMPREPLY=( $(compgen -W "$POSLIST $OPTLIST" -- "$CUR") )
}

# Main entry point for mbuild argument completions.
_mbuild()
{
  # Memo-ize the word we're trying to complete.
  local CUR="${COMP_WORDS[$COMP_CWORD]}"

  # If this is the first word (after the program name itself), the only thing
  # it can be is the help option or a commandgroup.
  if [[ $COMP_CWORD == 1 ]]
  then
    COMPREPLY=( $(compgen -W "--help cmd seq vals export import" -- "$CUR") )
    return 0
  fi

  # If this after the first word, bail out now if the first word was not a valid
  # commandgroup. (This includes if it was a help option.)
  local CMD_GROUP="${COMP_WORDS[1]}"
  echo "cmd seq vals export import" | grep -qw -- "$CMD_GROUP"
  if [[ $? -ne 0 ]]
  then
    return 0
  fi

  # OK! Things are still pretty simple for the second word. There is a small
  # number of valid options, or if the commandgroup was cmd/seq then this must
  # be an operation (if it's not the help option).
  if [[ $COMP_CWORD == 2 ]]
  then
    if [[ "$CMD_GROUP" == "cmd" || "$CMD_GROUP" == "seq" ]]
    then
      COMPREPLY=( $(compgen -W "--help list set edit info del run vals" -- "$CUR") )
    elif [[ "$CMD_GROUP" == "import" || "$CMD_GROUP" == "export" ]]
    then
      _mbuild_import_export_completions "$CMD_GROUP" 0 0
    elif [[ "$CMD_GROUP" == "vals" ]]
    then
      _mbuild_vals_completions 0
    fi
    return 0
  fi

  # After word 2 we will need to do some looking through all args in the
  # command line up through the COMP_CWORD position. For cmd/seq commandgroups
  # we'll start at position 3; for anything else we start at position 2. Also,
  # if we're in the cmd/seq commandgroups, bail out now if the second word was
  # not a valid operation (this includes if it was a help option). We'll also
  # bail out if the help option was specified right after operation, or right
  # after one of the other commandgroups.
  local SCAN_START
  if [[ "$CMD_GROUP" == "cmd" || "$CMD_GROUP" == "seq" ]]
  then
    local OPERATION="${COMP_WORDS[2]}"
    echo "list set edit info del run vals" | grep -qw -- "$OPERATION"
    if [[ $? -ne 0 ]]
    then
      return 0
    fi
    if [[ $COMP_CWORD != 3 ]]
    then
      if [[ "${COMP_WORDS[3]}" == "-h" || "${COMP_WORDS[3]}" == "--help" ]]
      then
        return 0
      fi
    fi
    SCAN_START=3
  else
    if [[ "${COMP_WORDS[2]}" == "-h" || "${COMP_WORDS[2]}" == "--help" ]]
    then
      return 0
    fi
    SCAN_START=2
  fi

  # Note that if "--help" shows up in subsequent args in the command line,
  # from this point on we will still do completion on other words even though
  # the help option short-circuits any other activity. Not sure what the best
  # approach is for dealing with that non-confusingly.

  # We can complete an option if the commandline doesn't have a prior "--",
  # and we can also complete on a command name, sequence name, or filename
  # depending on the prior args and the position of the argument. So we need
  # to look through the arguments now.

  # Also, let's talk about the way argparse is used by mbuild. You can't put
  # an option in the middle of a "varying number" positional arglist. Those
  # arglists appear in:
  #   cmd del, with the list of cmdnames to delete
  #   cmd run or vals, with the list of placeholders
  #   seq set, with the list of cmdnames
  #   seq del, with the list of seqnames to delete
  #   seq run or vals, with the list of placeholders
  #   vals, with the list of placeholders
  # It's actually fine to place an option AFTER such an arglist, but if you
  # are typing out args generally in order, the least confusing approach
  # for autocomplete would be to not offer autocomplete for options once such
  # an arglist has started. To generally detect/enforce that, we'll set NO_FLAGS
  # if we encounter a positional argument in the scan. This also mirrors what
  # the helptext indicates.

  # Scan up to just before our current position.
  local NO_FLAGS=0
  local FOUND_POSITIONAL=0
  local CHECK_SKIP=0
  if [[ "$CMD_GROUP" == "seq" && "$OPERATION" == "run" ]]
  then
    CHECK_SKIP=1
  fi
  if [[ $SCAN_START != $COMP_CWORD ]]
  then
    let SCAN_END=$COMP_CWORD-1
    for INDEX in $(seq $SCAN_START $SCAN_END)
    do
      local THIS_WORD="${COMP_WORDS[$INDEX]}"
      # See if "--" prevents later options.
      if [[ "$THIS_WORD" == "--" ]]
      then
        NO_FLAGS=1
        CHECK_SKIP=0
        continue
      fi
      # If this word is an option, keep looking.
      if [[ $NO_FLAGS == 0 && "$THIS_WORD" == -* ]]
      then
        continue
      fi
      # Otherwise, we've probably found a positional arg. Only exception is
      # the "skip" arguments for seq run.
      if [[ $CHECK_SKIP == 1 ]]
      then
        local PREV_WORD="${COMP_WORDS[$INDEX-1]}"
        if [[ "$PREV_WORD" == "-s" || "$PREV_WORD" == "--skip" ]]
        then
          continue
        fi
      fi
      FOUND_POSITIONAL=1
      NO_FLAGS=1
    done
  fi

  # Use the scan results and generate completions.
  case "$CMD_GROUP" in
    cmd)
      _mbuild_cmd_completions "$OPERATION" $NO_FLAGS $FOUND_POSITIONAL
      ;;
    seq)
      _mbuild_seq_completions "$OPERATION" $NO_FLAGS $FOUND_POSITIONAL
      ;;
    import)
      _mbuild_import_export_completions "$CMD_GROUP" $NO_FLAGS $FOUND_POSITIONAL
      ;;
    export)
      _mbuild_import_export_completions "$CMD_GROUP" $NO_FLAGS $FOUND_POSITIONAL
      ;;
    vals)
      _mbuild_vals_completions $NO_FLAGS
  esac

  return 0
}

complete -F _mbuild mbuild

