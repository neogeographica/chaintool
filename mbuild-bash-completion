#!/usr/bin/env bash

if compopt 2> /dev/null
then
  true
else
  echo "Note: old bash shell version in use. Tab completion of directories for"
  echo "mbuild export/import arguments will have an annoying space at the end."
  if [[ $(uname -s) == "Darwin" ]]
  then
    echo "cf. https://itnext.io/upgrading-bash-on-macos-7138bd1066ba"
  fi
fi

_set_file_completions()
{
  CUR="$1"
  if compopt -o filenames 2> /dev/null
  then
    COMPREPLY=( $(compgen -f -- "$CUR") )
  else
    COMPREPLY=()
    local TEMP_COMPREPLY=$(compgen -f -- "$CUR")
    if [[ -n "$TEMP_COMPREPLY" ]]
    then
      while IFS= read -r COMP
      do
        if [[ -d "$COMP" ]]
        then
          COMPREPLY+=("$COMP/")
        else
          COMPREPLY+=("$COMP")
        fi
      done <<< "$TEMP_COMPREPLY"
    fi
  fi
}

_mbuild()
{
  # Memo-ize the word we're trying to complete.
  local CUR="${COMP_WORDS[$COMP_CWORD]}"

  # If it starts with a dash, for now we'll assume it's an option.
  local IS_FLAG=0
  if [[ "$CUR" == -* ]]
  then
    IS_FLAG=1
  fi

  # XX Currently showing "option" type completions if and only if CUR starts
  # with a hyphen and is not preceded by "--". The latter criterion is fine
  # but maybe relax the former? Especially if CUR is emptystring it would be
  # nice to see available options when hitting tab?

  # If this is the first word (after the program name itself), the only thing
  # it can be is the help option or a commandgroup.
  if [[ $COMP_CWORD == 1 ]]
  then
    if [[ $IS_FLAG == 1 ]]
    then
      COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
    else
      COMPREPLY=( $(compgen -S ' ' -W "cmd seq vals export import" -- "$CUR") )
    fi
    return 0
  fi

  # If this after the first word, bail out now if the first word was not a valid
  # commandgroup. (This includes if it was a help option.)
  local CMD_GROUP="${COMP_WORDS[1]}"
  echo "cmd seq vals export import" | grep -qw -- "$CMD_GROUP"
  if [[ $? -ne 0 ]]
  then
    return 0
  fi

  # OK! Things are still pretty simple for the second word. There is a small
  # number of valid options, or if the commandgroup was cmd/seq then this must
  # be an operation (if it's not the help option).
  if [[ $COMP_CWORD == 2 ]]
  then
    if [[ $IS_FLAG == 1 ]]
    then
      if [[ "$CMD_GROUP" == "import" ]]
      then
        COMPREPLY=( $(compgen -W "--help --overwrite" -- "$CUR") )
      else
        COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
      fi
    else
      if [[ "$CMD_GROUP" == "cmd" || "$CMD_GROUP" == "seq" ]]
      then
        COMPREPLY=( $(compgen -W "list set edit info del run vals" -- "$CUR") )
      fi
    fi
    if [[ "$CMD_GROUP" == "cmd" || "$CMD_GROUP" == "seq" ]]
    then
      return 0
    fi
  fi

  # After word 2 we will need to do some looking through all args in the
  # command line up through the COMP_CWORD position. For cmd/seq commandgroups
  # we'll start at position 3; for anything else we start at position 2. Also,
  # if we're in the cmd/seq commandgroups, bail out now if the second word was
  # not a valid operation (this includes if it was a help option). We'll also
  # bail out if the help option was specified right after operation, or right
  # after one of the other commandgroups.
  local SCAN_START
  if [[ "$CMD_GROUP" == "cmd" || "$CMD_GROUP" == "seq" ]]
  then
    local OPERATION="${COMP_WORDS[2]}"
    echo "list set edit info del run vals" | grep -qw -- "$OPERATION"
    if [[ $? -ne 0 ]]
    then
      return 0
    fi
    if [[ $COMP_CWORD != 3 ]]
    then
      if [[ "${COMP_WORDS[3]}" == "-h" || "${COMP_WORDS[3]}" == "--help" ]]
      then
        return 0
      fi
    fi
    SCAN_START=3
  else
    if [[ "${COMP_WORDS[2]}" == "-h" || "${COMP_WORDS[2]}" == "--help" ]]
    then
      return 0
    fi
    SCAN_START=2
  fi

  # Note that if "--help" shows up in subsequent args in the command line,
  # from this point on we will still do completion on other words even though
  # the help option short-circuits any other activity. Not sure what the best
  # approach is for dealing with that non-confusingly.

  # We can complete an option if the commandline doesn't have a prior "--",
  # and we can also complete on a command name, sequence name, or filename
  # depending on the prior args and the position of the argument. So we need
  # to look through the arguments now.

  # Scan up to just before our current position.
  local NO_FLAGS=0
  local FOUND_POSITIONAL=0
  local CHECK_SKIP=0
  if [[ "$CMD_GROUP" == "seq" && "$OPERATION" == "run" ]]
  then
    CHECK_SKIP=1
  fi
  if [[ $SCAN_START != $COMP_CWORD ]]
  then
    let SCAN_END=$COMP_CWORD-1
    for INDEX in $(seq $SCAN_START $SCAN_END)
    do
      local THIS_WORD="${COMP_WORDS[$INDEX]}"
      # See if "--" prevents later options.
      if [[ "$THIS_WORD" == "--" ]]
      then
        NO_FLAGS=1
        IS_FLAG=0
        CHECK_SKIP=0
        continue
      fi
      # If this word is an option, keep looking.
      if [[ $NO_FLAGS == 0 && "$THIS_WORD" == -* ]]
      then
        continue
      fi
      # Otherwise, we've probably found a positional arg. Only exception is
      # the "skip" arguments for seq run.
      if [[ $CHECK_SKIP == 1 ]]
      then
        local PREV_WORD="${COMP_WORDS[$INDEX-1]}"
        if [[ "$PREV_WORD"=="-s" || "$PREV_WORD"=="--skip" ]]
        then
          continue
        fi
      fi
      FOUND_POSITIONAL=1
    done
  fi

  # If we still think the current word is an option, let's finish up.
  if [[ $IS_FLAG == 1 ]]
  then
    if [[ "$CMD_GROUP" == "cmd" ]]
    then
      if [[ "$OPERATION" == "list" ]]
      then
        COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
      elif [[ "$OPERATION" == "set" || "$OPERATION" == "edit" || "$OPERATION" == "vals" ]]
      then
        COMPREPLY=( $(compgen -W "--help --quiet" -- "$CUR") )
      elif [[ "$OPERATION" == "info" || "$OPERATION" == "run" ]]
      then
        COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
      elif [[ "$OPERATION" == "del" ]]
      then
        COMPREPLY=( $(compgen -W "--help --force" -- "$CUR") )
      fi
    elif [[ "$CMD_GROUP" == "seq" ]]
    then
      if [[ "$OPERATION" == "list" ]]
      then
        COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
      elif [[ "$OPERATION" == "set" || "$OPERATION" == "edit" ]]
      then
        COMPREPLY=( $(compgen -W "--help --force --quiet" -- "$CUR") )
      elif [[ "$OPERATION" == "info" || "$OPERATION" == "del" ]]
      then
        COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
      elif [[ "$OPERATION" == "run" ]]
      then
        COMPREPLY=( $(compgen -W "--help --ignore-errors --skip" -- "$CUR") )
      elif [[ "$OPERATION" == "vals" ]]
      then
        COMPREPLY=( $(compgen -W "--help --quiet" -- "$CUR") )
      fi
    elif [[ "$CMD_GROUP" == "import" ]]
    then
      COMPREPLY=( $(compgen -W "--help --overwrite" -- "$CUR") )
    elif [[ "$CMD_GROUP" == "export" || "$CMD_GROUP" == "vals"  ]]
    then
      COMPREPLY=( $(compgen -W "--help" -- "$CUR") )
    fi
    return 0
  fi

  # Current word is a positional arg, so let's find out what kind.
  local CUR_IS_CMDNAME=0
  local CUR_IS_SEQNAME=0
  local CUR_IS_FILENAME=0
  local CUR_IS_PLACEHOLDER_VALS=0
  local CUR_IS_PLACEHOLDER_RUN=0
  if [[ "$CMD_GROUP" == "cmd" ]]
  then
    if [[ "$OPERATION" == "list" ]]
    then
      true
    elif [[ "$OPERATION" == "set" || "$OPERATION" == "edit" || "$OPERATION" == "info" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        CUR_IS_CMDNAME=1
      fi
    elif [[ "$OPERATION" == "del" ]]
    then
      CUR_IS_CMDNAME=1
    elif [[ "$OPERATION" == "run" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        CUR_IS_CMDNAME=1
      else
        CUR_IS_PLACEHOLDER_RUN=1
      fi
    elif [[ "$OPERATION" == "vals" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        CUR_IS_CMDNAME=1
      else
        CUR_IS_PLACEHOLDER_VALS=1
      fi
    fi
  elif [[ "$CMD_GROUP" == "seq" ]]
  then
    if [[ "$OPERATION" == "list" ]]
    then
      true
    elif [[ "$OPERATION" == "set" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        CUR_IS_SEQNAME=1
      else
        CUR_IS_CMDNAME=1
      fi
    elif [[ "$OPERATION" == "edit" || "$OPERATION" == "info" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        CUR_IS_SEQNAME=1
      fi
    elif [[ "$OPERATION" == "del" ]]
    then
      CUR_IS_SEQNAME=1
    elif [[ "$OPERATION" == "run" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        local BEFORE_CUR="${COMP_WORDS[$COMP_CWORD-1]}"
        if [[ "$BEFORE_CUR"=="-s" || "$BEFORE_CUR"=="--skip" ]]
        then
          CUR_IS_CMDNAME=1
        else
          CUR_IS_SEQNAME=1
        fi
      else
        CUR_IS_PLACEHOLDER_RUN=1
      fi
    elif [[ "$OPERATION" == "vals" ]]
    then
      if [[ $FOUND_POSITIONAL == 0 ]]
      then
        CUR_IS_SEQNAME=1
      else
        CUR_IS_PLACEHOLDER_VALS=1
      fi
    fi
  elif [[ "$CMD_GROUP" == "import" || "$CMD_GROUP" == "export" ]]
  then
    if [[ $FOUND_POSITIONAL == 0 ]]
    then
      CUR_IS_FILENAME=1
    fi
  elif [[ "$CMD_GROUP" == "vals" ]]
  then
    CUR_IS_PLACEHOLDER_VALS=1
  fi

  # For now we can handle command name, sequence name, or filename.
  if [[ $CUR_IS_CMDNAME == 1 ]]
  then
    local CMDLIST=$("${COMP_WORDS[0]}" cmd list)
    COMPREPLY=( $(compgen -W "$CMDLIST" -- "$CUR") )
  elif [[ $CUR_IS_SEQNAME == 1 ]]
  then
    local SEQLIST=$("${COMP_WORDS[0]}" seq list)
    COMPREPLY=( $(compgen -W "$SEQLIST" -- "$CUR") )
  elif [[ $CUR_IS_FILENAME == 1 ]]
  then
    _set_file_completions "$CUR"
  fi

  # XXX Maybe placeholder support next!

  return 0
}

complete -F _mbuild mbuild

